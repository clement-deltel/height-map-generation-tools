package models.algorithms;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.HashMap;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import controllers.LoggerAlgorithm;
import javafx.concurrent.Task;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.image.Image;
import models.Map;

public abstract class AlgorithmModel extends Task<Image> {
	
	protected Map map;
	protected int size;
	protected java.util.Map<String, String> parameters;
	protected java.util.Map<String, String> statistics;
	
	protected double pointDone = 0;
	protected double progress;
	
	protected boolean reformat = true;
	
	Logger LOGGER = Logger.getLogger( LoggerAlgorithm.class.getName());
	
	AlgorithmModel(int size){
		this.size = size;
		this.map = new Map(this.size);
		this.parameters = new HashMap<String,String>();
		this.setParameter("size", this.size);
		this.statistics = new HashMap<String,String>();
	}
	
	/**
	 * Apply the current algorithm to the Map.
	 */
	public abstract void apply();
	
	/**
	 * Return all parameter of the algorithm.
	 * @return java.util.Map<String,String> all the parameters of the algorithm.
	 */
	public java.util.Map<String, String> getParameters() {
		return this.parameters;
	}
	
	/**
	 * Return parameter of the algorithm.
	 * @param key Parameter that is wanted to be retrieved.
	 * @return The value of the parameter.
	 */
	public String getParameter(String key) {
		return this.parameters.get(key);
	}
	
	/**
	 * Set Parameters in Algorithm. It connects UI with algorithm parameters.
	 * 
	 * Every Algorithm should override this method, and call super(java.util.Map<String,String>).
	 * Then the algorithm can add its own parameters from the java.util.Map<String,String>. 
	 * @param parametersMap java.util.Map<String,String>
	 */
	public void setParameters(java.util.Map<String,String> parametersMap) {
		reformat = Boolean.parseBoolean(parametersMap.get("reformat"));
		this.parameters = parametersMap;
	}
	
	/**
	 * Set parameter in Map's parameters.
	 * @param key Key of the parameter.
	 * @param value Value of the parameter.
	 */
	public void setParameter(String key, Object value) {
		this.parameters.put(key, String.valueOf(value));
	}

	/**
	 * Set progress value and update progress bar in UI where the task was started.
	 * @param progress double Progress value
	 */
	private void setProgress(double progress) {
		if (progress >= 0 && progress <= 1)
			this.progress = progress;
		updateProgress(progress, 1);
	}
	
	/**
	 * Update the number of calculated point and set the progress as following :
	 * Progress = (Point Done)/(Map's size²)
	 * 
	 * Should be called when point is calculated in normal way.
	 */
	protected void pointCalculated() {
		pointDone++;
		this.setProgress((double)(pointDone/((double)this.size*this.size)));
	}
	
	/**
	 * Update the number of calculated point and set the progress as following :
	 * Progress = (Point Done)/(total)
	 * 
	 * Should be called when point is calculated and the total of points is different from the Map's size².
	 * @param total The total of point that will be calculated.
	 */
	protected void pointCalculated(int total) {
		pointDone++;
		this.setProgress((double)(pointDone/((double)total)));
	}
	
	/**
	 * Generate Swing Image from the Map using the BufferedImage.TYPE_INT_RGB.
	 * If reformat field of algorithm is true, the image will be standard.
	 * If reformat field is set false, the image could have artifacts.
	 * @return Swing Image of the Map.
	 */
	public Image generateImage() {
		if (reformat)
			this.reformatValue();
		BufferedImage img = new BufferedImage(this.map.getSize(), this.map.getSize(),BufferedImage.TYPE_INT_RGB);
		for (int j=0;j<this.map.getSize(); j++) {
			for (int i=0; i<this.map.getSize(); i++) {
				img.setRGB(i, j, (int)this.map.get(i,j)+((int)this.map.get(i,j)<<8)+((int)this.map.get(i,j)<<16));
			}
		}
		/*try {
			File f = new File("test.png");
			ImageIO.write(img,  "png", f);
		}catch (IOException e) {
			System.out.println("Error: "+e);
		}*/
		return SwingFXUtils.toFXImage(img, null);
	}
	
	/**
	 * Do a projection of the range of Map's values into the range [0,255].
	 */
	protected void reformatValue() {
		double a = 255.0/(map.getMax()-map.getMin());
		double b = 255.0/(map.getMax()-map.getMin())*map.getMin();
		for (int j=0;j<this.map.getSize(); j++) {
			for (int i=0; i<this.map.getSize(); i++) {
					map.set(i, j, a*map.get(i, j)-b);
			}
		}
	}
	
	/**
	 * Return statistics of the map generated by the algorithm.
	 * @return HashMap<String,String>.
	 */
	public java.util.Map<String, String> getStatistics() {
		return this.statistics;
	}
	
	/**
	 * Calculate statistics about map and store it HashMap<String, String> this.statistics.
	 * Statistics : size, max, min, average, median. 
	 */
	protected void calculateStatistics() {
		this.statistics.put("size", String.valueOf(this.map.getSize()));
		if (!this.isCancelled())
			this.statistics.put("min", String.valueOf(this.map.getMin()));
		if (!this.isCancelled()) 
			this.statistics.put("max", String.valueOf(this.map.getMax()));
		if (!this.isCancelled()) 
			this.statistics.put("average", String.valueOf(this.map.getAverage()));
		if (!this.isCancelled()) 
			this.statistics.put("median", String.valueOf(this.map.getMedian()));
	}
	
	/**
	 * Create a one line String of map's statistics.
	 * @return String One line string of all map's statistics.
	 */
	protected String prettyStatistics() {
		String s ="";
		for (String key : this.statistics.keySet())
			s += key + " : " + this.statistics.get(key)+ ", ";
		s = s.substring(0, s.length()-2);
		return s;
	}
	
	/**
	 * Use to start calculating algorithm task in Thread.
	 * 1st step : Apply algorithm
	 * 2nd step : Calculate statistics
	 * 3th step : Generate Image
	 * 
	 * If Task is cancelled, all the step can be cancelled and not executed.
	 * @return javafx.scene.image.Image Image of the generated map.
	 */
	@Override
	protected Image call() throws Exception {
		updateMessage("In progress...");
		this.log("Applying "+this+ String.format(" on a Map of size : %dx%d",this.size,this.size));
		this.apply();
		updateMessage("Calculating statistics...");
		if (!this.isCancelled())
			calculateStatistics();
		if (!this.isCancelled())
			this.log("Statistics : "+this.prettyStatistics());
		Image img;
		if (!this.isCancelled()) {
			updateMessage("Generating image...");
			img = this.generateImage();
			this.log(String.format("Generated Image, size : %dx%dpx",(int)img.getHeight(),(int)img.getWidth()));
			this.log("Success");
			updateMessage("Displaying image...");
			return img;
		}
		log("Task has been cancelled.");
		return null;
	}
	
	/**
	 * Log to LoggerAlgorithm.fileLogName and into the console.
	 * The output log looks like :
	 * 	Date Time INFOS models.algotithms.ALGORITHMN_NAME YOUR_MESSAGE
	 * @param msg Message to log
	 */
	protected void log(String msg) {
		try {
			//Uncomment to hide in Console.
			//LOGGER.setUseParentHandlers(false);
			Handler fh = new FileHandler(LoggerAlgorithm.fileLogName, true);
			fh.setEncoding("UTF-8");
			fh.setFormatter(new SimpleFormatter());
			LOGGER.addHandler(fh);
			LOGGER.log(Level.INFO, msg);
			fh.close();
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public String toString() {
		return this.getClass().getName();
	}
	
}
